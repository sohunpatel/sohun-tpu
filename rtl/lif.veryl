module lif #(
    param WEIGHT_WIDTH: u32 = 32  ,
    param N_INPUTS    : u32 = 10  ,
    param TAU_RC      : u32 = 1000,
    param TAU_REF     : u32 = 10  ,
) (
    i_clk   : input  clock                         ,
    i_rst   : input  reset                         ,
    i_spikes: input  bit  <WEIGHT_WIDTH> [N_INPUTS],
    o_spike : output bit  <1>                      ,
) {
    enum State: bit {
        accumulate,
        refactory,
    }

    var voltage          : bit  <64>             ;
    var spike_out        : bit                   ;
    var refactory_counter: bit  <$clog2(TAU_REF)>;
    var state            : State                 ;

    always_ff (i_clk, i_rst) {
        if_reset {
            voltage           = 0;
            state             = State::accumulate;
            spike_out         = 0;
            refactory_counter = '1;
        } else {
            if state == State::accumulate {
                // neuron dynamics
                // dv/dt = 1/tau_rc * (J_inj - v)

                if voltage[63:32] >: 0 {
                    spike_out         = 1;
                    refactory_counter = TAU_REF;
                    state             = State::refactory;
                }
            } else if state == State::refactory {
                refactory_counter -= 1;

                if refactory_counter == 0 {
                    state = State::accumulate;
                }
            }
        }
    }

    assign o_spike = spike_out;
}
